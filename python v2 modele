import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from mpl_toolkits.mplot3d import Axes3D

TempsTotal = 50  #temps simulation

#paramètres à confirmer plaque dimension
Lx, Ly = 100e-3, 50e-3  #dimensions plaque en m
Nx, Ny = 50, 25  #nb elements
dx, dy = Lx / Nx, Ly / Ny  #le pas
epaisseur = 1.5e-3  #épaisseur plaque en m
volume = dx*dy*epaisseur

#propriétés matériau
k = 205  #conductivité thermique en W/m·K
rho = 2700  #densité en kg/m^3
cp = 900  #chaleur spécifique en J/kg·K
alpha = k / (rho * cp)  #diffusivité thermique m^2/s
#TEST GIT

h_conv = 15  #coeff de convection en W/m^2·K

Temp_ambiante = 273 + 20  #température ambiante en K

#Cond. stabilité CFL pour stabilité numérique YOAN A 8 ET NON 4
dt = min(dx**2, dy**2) / (4 * alpha)


#matrice start


#C.I.
Temp_init = 273.15 + 25 #298 K = 25 Celcius
T = np.full((Nx, Ny), Temp_init)  #champ température init. donc start à 25 C essayer ones
Temp_nouvelle = np.zeros_like(T)

Nt = int(TempsTotal / dt)  #nb d'itérations temporelles

# Position capteurs (à ajuster)
laser_x, laser_y = Nx // 10, Ny // 10
milieu_x, milieu_y = Nx // 2, Ny // 2
actuateur_x, actuateur_y = 3 * Nx // 4, 3 * Ny // 4

#source de chaleur ponctuelle
Pin = 500  #puissance totale en W
P = np.zeros((Nx, Ny))
P[laser_x, laser_y] = Pin / (dx * dy)  #source ponctuelle



temperature_laser = np.zeros(Nt)
temperature_milieu = np.zeros(Nt)
temperature_actuateur = np.zeros(Nt)

#grilles
x = np.linspace(0, Lx * 1e3, Nx)  #m en mm
y = np.linspace(0, Ly * 1e3, Ny)
X, Y = np.meshgrid(x, y)


fig = plt.figure(figsize=(12, 5))
ax1 = fig.add_subplot(121, projection='3d')  #température 3D
ax2 = fig.add_subplot(122)  #température laser, milieu, actuateur (comme exemple diapo. présentation projet)

def update_temp():
    global T, Temp_nouvelle
    for i in range(1, Nx - 1):
        for j in range(1, Ny - 1):
            #discrétisation eq. diff. en différences finies
            Temp_nouvelle[i, j] = T[i, j] + alpha * dt * (
                (T[i + 1, j] - 2 * T[i, j] + T[i - 1, j]) / dx**2 +
                (T[i, j + 1] - 2 * T[i, j] + T[i, j - 1]) / dy**2
            ) + dt * P[i, j] / (rho * cp)

    #Cond. lim de convection (bords de la plaque)
    for i in range(Nx):
        for j in range(Ny):
            if i == 0 or i == Nx - 1 or j == 0 or j == Ny - 1:
                Temp_nouvelle[i, j] += dt / (rho * cp) * h_conv * (Temp_ambiante - T[i, j]) / epaisseur

    T[:, :] = Temp_nouvelle[:, :]

def update(frame):
    update_temp()
    

    temperature_laser[frame] = T[laser_x, laser_y]
    temperature_milieu[frame] = T[milieu_x, milieu_y]
    temperature_actuateur[frame] = T[actuateur_x, actuateur_y]

    ax1.clear()
    ax2.clear()
    
   
    ax1.plot_surface(X, Y, T.T, cmap='PuRd')
    ax1.set_xlabel("X position [mm]")
    ax1.set_ylabel("Y position [mm]")
    ax1.set_zlabel("Température (K)")
    ax1.set_title(f"Distribution de température à t = {frame * dt:.4f} s")

    
    time_vector = np.arange(frame) * dt
    ax2.plot(time_vector, temperature_laser[:frame] - 273, label="Au laser")
    ax2.plot(time_vector, temperature_milieu[:frame] - 273, label="Au milieu")
    ax2.plot(time_vector, temperature_actuateur[:frame] - 273, label="À l'actuateur")
    
    ax2.set_xlabel("Temps [s]")
    ax2.set_ylabel("Température [°C]")
    ax2.legend()
    ax2.set_xlim([0, TempsTotal])
    ax2.set_ylim([20, 35])
    ax2.grid(True)


video = animation.FuncAnimation(fig, update, frames=Nt, repeat=False)


video.save('TemperatureDistribution2D.mp4', writer='ffmpeg', fps=30, extra_args=['-vcodec', 'libx264', '-pix_fmt', 'yuv420p'])

plt.show()



















#def vector_evolution_temperature(T, pos_ac, nx_ac, ny_ac, P_ac = None,
#                                P_pert = None , pos_pert = None , nx_pert = None, ny_pert = None):
 #   T_new = T.copy()
  #  vol = dx*dy*dz



   # #conductions éléments centraux
  #  T_new[1:-1,1:-1] = T[1:-1, 1:-1] + a*dt*((T[2:,1:-1]-2*T[1:-1, 1:-1] +T[0:-2, 1:-1])/(dx**2) +
 #                                           (T[1:-1,2:]-2*T[1:-1, 1:-1] +T[1:-1, 0:-2])/(dy**2))
    
    # conduction éléments sur les bords et coins
 #   T_new[0, 1:-1] += a * dt * ((T[1, 1:-1] - T[0, 1:-1]) / dx**2 +
 #                               (T[0, 2:] - 2 * T[0, 1:-1] + T[0, :-2]) / dy**2)  # Bord haut

 #   T_new[-1, 1:-1] += a * dt * ((T[-2, 1:-1] - T[-1, 1:-1]) / dx**2 +
 #                                (T[-1, 2:] - 2 * T[-1, 1:-1] + T[-1, :-2]) / dy**2)  # Bord bas

  #  T_new[1:-1, 0] += a * dt * ((T[2:, 0] - 2 * T[1:-1, 0] + T[:-2, 0]) / dx**2 +
  #                              (T[1:-1, 1] - T[1:-1, 0]) / dy**2)  # Bord gauche

 #   T_new[1:-1, -1] += a * dt * ((T[2:, -1] - 2 * T[1:-1, -1] + T[:-2, -1]) / dx**2 +
 #                                (T[1:-1, -2] - T[1:-1, -1]) / dy**2)  # Bord droit

  #  T_new[0, 0] += a * dt * ((T[1, 0] - T[0, 0]) / dx**2 + (T[0, 1] - T[0, 0]) / dy**2)  # Coin haut-gauche

  #  T_new[0, -1] += a * dt * ((T[1, -1] - T[0, -1]) / dx**2 + (T[0, -2] - T[0, -1]) / dy**2)  # Coin haut-droit

  #  T_new[-1, 0] += a * dt * ((T[-2, 0] - T[-1, 0]) / dx**2 + (T[-1, 1] - T[-1, 0]) / dy**2)  # Coin bas-gauche

  #  T_new[-1, -1] += a * dt * ((T[-2, -1] - T[-1, -1]) / dx**2 + (T[-1, -2] - T[-1, -1]) / dy**2)  # Coin bas-droit
    



    # Convection 
  #  Coeff = (h*dt)/(p*cp) #m

    #Convection bord haut
  #  T_new[0, :] += Coeff*(T_air-T_new[0,:])*((dz*dx)/(vol))

    #Convection bord bas
#    T_new[-1, :] +=  Coeff*(T_air-T_new[-1,:])*((dz*dx)/(vol))
    
    #Convection bord gauche
  #  T_new[:,0] += Coeff*(T_air-T_new[:,0])*((dz*dy)/(vol))

    #Convection bord droit 
   # T_new[:,-1] += Coeff*(T_air-T_new[:,-1])*((dz*dy)/(vol))

    #Convection dessus/desosus
   # T_new[:,:] +=  2*Coeff*(T_air-T_new[:,:])*((dx*dy)/vol)



    # Actuateur
  #  i, j = pos_ac
  #  P_par_element = P_ac/(nx_ac*ny_ac)
  #  T_new[i-nx_ac//2: i+nx_ac//2 , j-ny_ac//2 : j + ny_ac//2 ] += (P_par_element*dt)/(p*cp*vol)

    # Perturbation
 #   if P_pert is not None :
 #       i, j = pos_pert
  #      P_par_element = P_pert/(nx_pert*ny_pert)
  #      T_new[i-nx_pert//2:i+nx_pert//2, j-ny_pert//2:j+ny_pert//2] += (P_par_element*dt)/(p*cp*vol)

  #  return T_new