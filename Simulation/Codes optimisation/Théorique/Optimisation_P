import matplotlib.pyplot as plt
import numpy as np
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D
import json
import tkinter
import csv

# Charger les paramÃ¨tres de simulation
with open('parametres_simulationYD.json', 'r') as f:
    params = json.load(f)

# PropriÃ©tÃ©s thermiques et physiques
k = params["proprietes_thermiques"]["k"]
p = params["proprietes_thermiques"]["p"]
cp = params["proprietes_thermiques"]["cp"]
Lx = params["dimensions_plaque"]["Lx"]
Ly = params["dimensions_plaque"]["Ly"]
e = params["dimensions_plaque"]["e"]
T_air = params["convection"]["T_air"]

# DiscrÃ©tisation
n_x = params["discretisation"]["n_x"]
n_y = params["discretisation"]["n_y"]
dx = Lx / n_x
dy = Ly / n_y
dz = e
vol = dx * dy * e

# Simulation
a = k / (cp * p)
dt = 0.001
temps_simulation = params["simulation"]["temps_simulation"]
Nt = int(temps_simulation / dt)

# ParamÃ¨tres actuateur
pos_ac = tuple(params["simulation"]["pos_ac"])
nx_ac = params["simulation"]["nx_ac"]
ny_ac = params["simulation"]["ny_ac"]
h = params["convection"]["h"]

# Fonction d'Ã©volution de la tempÃ©rature (DOIT RESTER IDENTIQUE)
def vector_evolution_temperature(T, h, pos_ac, nx_ac, ny_ac, P_ac=None,
                               P_pert=None, pos_pert=None, nx_pert=None, ny_pert=None):
    T_new = T.copy()

    # Conduction Ã©lÃ©ments centraux
    T_new[1:-1,1:-1] = T[1:-1, 1:-1] + a*dt*((T[2:,1:-1]-2*T[1:-1, 1:-1] +T[0:-2, 1:-1])/(dy**2) +
                                           (T[1:-1,2:]-2*T[1:-1, 1:-1] +T[1:-1, 0:-2])/(dx**2))
    
    # Conduction bords et coins
    T_new[0, 1:-1] += a * dt * ((T[1, 1:-1] - T[0, 1:-1]) / dy**2 +
                               (T[0, 2:] - 2 * T[0, 1:-1] + T[0, :-2]) / dx**2)
    
    T_new[-1, 1:-1] += a * dt * ((T[-2, 1:-1] - T[-1, 1:-1]) / dy**2 +
                                (T[-1, 2:] - 2 * T[-1, 1:-1] + T[-1, :-2]) / dx**2)
    
    T_new[1:-1, 0] += a * dt * ((T[2:, 0] - 2 * T[1:-1, 0] + T[:-2, 0]) / dy**2 +
                               (T[1:-1, 1] - T[1:-1, 0]) / dx**2)
    
    T_new[1:-1, -1] += a * dt * ((T[2:, -1] - 2 * T[1:-1, -1] + T[:-2, -1]) / dy**2 +
                                (T[1:-1, -2] - T[1:-1, -1]) / dx**2)
    
    # Coins
    T_new[0, 0] += a * dt * ((T[1, 0] - T[0, 0]) / dy**2 + (T[0, 1] - T[0, 0]) / dx**2)   
    T_new[0, -1] += a * dt * ((T[1, -1] - T[0, -1]) / dy**2 + (T[0, -2] - T[0, -1]) / dx**2) 
    T_new[-1, 0] += a * dt * ((T[-2, 0] - T[-1, 0]) / dy**2 + (T[-1, 1] - T[-1, 0]) / dx**2)   
    T_new[-1, -1] += a * dt * ((T[-2, -1] - T[-1, -1]) / dy**2 + (T[-1, -2] - T[-1, -1]) / dx**2)

    # Convection
    Coeff = (h*dt)/(p*cp)
    T_new[0, :] += 1*Coeff*(T_air-T[0,:])*((dz*dx)/(vol))     # haut   #ici, j'ai mis un coefficient 1 parce que si je veux enlever la convection juste sur 1 cote, il me suffira juste de rempacer 1 par 0
    T_new[-1, :] += 1*Coeff*(T_air-T[-1,:])*((dz*dx)/(vol))   # bas
    T_new[:,0] += 1*Coeff*(T_air-T[:,0])*((dz*dy)/(vol))      # gauche
    T_new[:,-1] += 1*Coeff*(T_air-T[:,-1])*((dz*dy)/(vol))    # droite
    T_new[:,:] += 2*Coeff*(T_air-T[:,:])*((dx*dy)/vol)      # dessus/dessous  #ici, le coefficient doit etre a 2 si on veut que les 2 surfaces soient soumises a la convection

    # Actuateur
    if P_ac is not None:
        i, j = pos_ac
        P_par_element = P_ac/(nx_ac*ny_ac)
        T_new[i-nx_ac//2:i+nx_ac//2, j-ny_ac//2:j+ny_ac//2] += (P_par_element*dt)/(p*cp*vol)

    # Perturbation
    if P_pert is not None and P_pert > 0:
        k, l = pos_pert
        P_par_element = P_pert/(nx_pert*ny_pert)
        T_new[k-nx_pert//2:k+nx_pert//2, l-ny_pert//2:l+ny_pert//2] += (P_par_element*dt)/(p*cp*vol)

    return T_new


P_ref = 1.0 # Valeur fixe pour la simulation de rÃ©fÃ©rence
T_ref = np.ones((n_x, n_y)) * 297.47
temp_therm_1_ref, temp_therm_2_ref, temp_therm_laser_ref = [], [], []

for _ in range(Nt):
    T_ref = vector_evolution_temperature(T_ref, h, pos_ac, nx_ac, ny_ac, P_ref)
    temp_therm_1_ref.append(T_ref[30, 15] - 273.15)
    temp_therm_2_ref.append(T_ref[30, 60] - 273.15)
    temp_therm_laser_ref.append(T_ref[30, 105] - 273.15)


P_values = np.arange(0.9, 1.2, 0.1)
errors = []

for P in P_values:
    T_test = np.ones((n_x, n_y)) * 297.47
    temp_therm_1_test, temp_therm_2_test, temp_therm_laser_test = [], [], []
    print(f'{P}')

    for _ in range(Nt):
        T_test = vector_evolution_temperature(T_test, h, pos_ac, nx_ac, ny_ac, P)
        temp_therm_1_test.append(T_test[30, 15] - 273.15)
        temp_therm_2_test.append(T_test[30, 60] - 273.15)
        temp_therm_laser_test.append(T_test[30, 105] - 273.15)
       

    # Calcul de l'erreur quadratique moyenne (MSE)
    error = np.sum((np.array(temp_therm_1_test) - np.array(temp_therm_1_ref))**2) + \
            np.sum((np.array(temp_therm_2_test) - np.array(temp_therm_2_ref))**2) + \
            np.sum((np.array(temp_therm_laser_test) - np.array(temp_therm_laser_ref))**2)

    errors.append(error)

# ğŸ”¹ **SÃ©lection du meilleur h**
P_optimal = P_values[np.argmin(errors)]
print(f"Valeur optimale de h trouvÃ©e : {P_optimal:.2f} W/mÂ²K")

# ğŸ”¹ **Simulation avec h optimal**
T_best = np.ones((n_x, n_y)) * 297.47
temp_therm_1_best, temp_therm_2_best, temp_therm_laser_best = [], [], []

for _ in range(Nt):
    T_best = vector_evolution_temperature(T_best, h, pos_ac, nx_ac, ny_ac, P_optimal)
    temp_therm_1_best.append(T_best[30, 15] - 273.15)
    temp_therm_2_best.append(T_best[30, 60] - 273.15)
    temp_therm_laser_best.append(T_best[30, 105] - 273.15)

# ğŸ”¹ **Affichage des rÃ©sultats**
times = np.arange(len(temp_therm_1_ref)) * dt

plt.figure(figsize=(10, 5))

# Thermistance 1
plt.plot(times, temp_therm_1_ref, linestyle='-', color='r', label='RÃ©f Thermistance 1')
plt.plot(times, temp_therm_1_best, linestyle='--', color='r', label=f'Test Thermistance 1 (h={P_optimal:.2f})')

# Thermistance 2
plt.plot(times, temp_therm_2_ref, linestyle='-', color='y', label='RÃ©f Thermistance 2')
plt.plot(times, temp_therm_2_best, linestyle='--', color='y', label=f'Test Thermistance 2 (h={P_optimal:.2f})')

# Thermistance 3
plt.plot(times, temp_therm_laser_ref, linestyle='-', color='k', label='RÃ©f Thermistance Laser')
plt.plot(times, temp_therm_laser_best, linestyle='--', color='k', label=f'Test Thermistance Laser (h={P_optimal:.2f})')

plt.xlabel("Temps (s)")
plt.ylabel("TempÃ©rature (Â°C)")
plt.title("Comparaison des tempÃ©ratures des thermistances")
plt.legend()
plt.grid(True)
plt.show()

