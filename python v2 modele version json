import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D
import json
import tkinter as tk
from tkinter import ttk

#charge les paramètres à partir du fichier JSON
with open('simulation_parametres.json', 'r') as f:
    params = json.load(f)

TempsTotal = params['TempsTotal']  #temps de simulation

#paramètres à confirmer plaque dimension
Lx, Ly = params['Lx'], params['Ly']  #dimensions plaque en m
Nx, Ny = params['Nx'], params['Ny'] #nb elements

#propriétés physiques et matériau aluminium
k = params['k']  #conductivité thermique en W/m·K
rho = params['rho']  #densité en kg/m^3
cp = params['cp']  #chaleur spécifique en J/kg·K
alpha = k / (rho * cp)  #diffusivité thermique m^2/s
h_conv = params['h_conv']  # coeff de convection en W/m^2·K
Temp_ambiante = params['Temp_ambiante']  #température ambiante en K

#discrétisation
dx, dy = Lx / Nx, Ly / Ny
epaisseur = params['epaisseur']  #epaisseur plaque en m
volume = dx * dy * epaisseur
dt = min(dx**2, dy**2) / (4 * alpha)
Nt = int(TempsTotal / dt)

#C.I.
Temp_init = params['Temp_init']  # 298 K = 25°C
T = np.full((Nx, Ny), Temp_init)
Temp_nouvelle = np.zeros_like(T)

#sources de chaleur
actuateurs = params['actuateurs']
perturbations = params['perturbations']


#temp.
temperature_points = {name: [] for name in params['points_suivi']}

#construction grilles
x = np.linspace(0, Lx * 1e3, Nx)
y = np.linspace(0, Ly * 1e3, Ny)
X, Y = np.meshgrid(x, y)

#interface pour contrôle
root = tk.Tk()
root.title("Interface de contrôle de la simulation")

#curseur d'ajustement de puissance
puissance_var = tk.DoubleVar(value=actuateurs[0]['puissance'])
puissance_label = ttk.Label(root, text="Puissance de l'actuateur (W)")
puissance_label.pack()
puissance_slider = ttk.Scale(root, from_=1, to=1000, variable=puissance_var, orient='horizontal')
puissance_slider.pack()

#bouton démarrage
start_button = ttk.Button(root, text="Démarrer la simulation")
start_button.pack()

#start de la simulation
fig = plt.figure(figsize=(14, 6))
ax1 = fig.add_subplot(131)
ax2 = fig.add_subplot(132, projection='3d')
ax3 = fig.add_subplot(133)
cmap = plt.get_cmap('PuRd')

#graphiques
im = ax1.imshow(T, cmap=cmap, interpolation='nearest')
surf = ax2.plot_surface(X, Y, T.T, cmap=cmap)
time_vector = []

#très important : ne pas changer ;) ahahhaha
temperature_lines = {}
rose_colors = ['deeppink', 'hotpink', 'mediumvioletred', 'orchid', 'palevioletred'] #DO NOT CHANGE, WILL FAIL TO COMPUTE

for (name, _), color in zip(params['points_suivi'].items(), rose_colors):
    line, = ax3.plot([], [], label=name, color=color)
    temperature_lines[name] = line

ax3.set_xlabel("Temps (s)")
ax3.set_ylabel("Température (°C)")
ax3.legend()



#fc de température
def update_temp():
    global T, Temp_nouvelle
    T_new = T.copy()

    # Conduction
    T_new[1:-1,1:-1] += alpha * dt * (
        (T[2:,1:-1] - 2 * T[1:-1,1:-1] + T[:-2,1:-1]) / dx**2 +
        (T[1:-1,2:] - 2 * T[1:-1,1:-1] + T[1:-1,:-2]) / dy**2
    )

    # Conditions aux limites de convection
    T_new[0, :] += dt / (rho * cp) * h_conv * (Temp_ambiante - T[0, :]) / epaisseur
    T_new[-1, :] += dt / (rho * cp) * h_conv * (Temp_ambiante - T[-1, :]) / epaisseur
    T_new[:, 0] += dt / (rho * cp) * h_conv * (Temp_ambiante - T[:, 0]) / epaisseur
    T_new[:, -1] += dt / (rho * cp) * h_conv * (Temp_ambiante - T[:, -1]) / epaisseur

    # Actuateurs
    for act in actuateurs:
        x_idx, y_idx = act['position']
        P = max(puissance_var.get(), 1)  # Éviter des valeurs trop proches de zéro
        T_new[x_idx, y_idx] += (P * dt) / (rho * cp * volume)

    T[:, :] = T_new[:, :]


#fc de mise à jour animation
def update(frame):
    global surf
    update_temp()
    im.set_data(T)
    
    # Supprimer la surface précédente
    surf.remove()
    surf = ax2.plot_surface(X, Y, T.T, cmap=cmap)

    time_vector.append(frame * dt)
    if len(time_vector) > 500:  # Limiter la taille pour éviter les ralentissements
        time_vector.pop(0)
        for name in temperature_points:
            temperature_points[name].pop(0)

    for name, pos in params['points_suivi'].items():
        temperature_points[name].append(T[pos[0], pos[1]])
        temperature_lines[name].set_data(time_vector, np.array(temperature_points[name]) - 273)

    ax3.relim()
    ax3.autoscale_view()
    return [im, surf, ax3]

ani = FuncAnimation(fig, update, frames=Nt//100, interval=50, blit=False)


def start_simulation():
    plt.show()

start_button.config(command=start_simulation)

root.mainloop()