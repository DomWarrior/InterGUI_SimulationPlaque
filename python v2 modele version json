import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D
import json
import tkinter as tk
from tkinter import ttk


#charge les paramètres à partir du fichier JSON
with open('simulation_parametres.json', 'r') as f:
    params = json.load(f)

TempsTotal = params['TempsTotal']  #temps de simulation

#paramètres à confirmer plaque dimension
Lx, Ly = params['Lx'], params['Ly']  #dimensions plaque en m
Nx, Ny = params['Nx'], params['Ny'] #nb elements

#propriétés physiques et matériau aluminium
k = params['k']  #conductivité thermique en W/m·K
rho = params['rho']  #densité en kg/m^3
cp = params['cp']  #chaleur spécifique en J/kg·K
alpha = k / (rho * cp)  #diffusivité thermique m^2/s
h_conv = params['h_conv']  # coeff de convection en W/m^2·K
Temp_ambiante = params['Temp_ambiante']  #température ambiante en K

#discrétisation
dx, dy = Lx / Nx, Ly / Ny
epaisseur = params['epaisseur']  #epaisseur plaque en m
volume = dx * dy * epaisseur
dt = min(dx**2, dy**2) / (8 * alpha)
Nt = int(TempsTotal / dt)



#C.I.
Temp_init = params['Temp_init']  # 298 K = 25°C
T = np.full((Nx, Ny), Temp_init)
coeff = (h_conv * dt)/(rho * cp)
T_air = 273.15 -20 # K




#sources de chaleur
actuateurs = params['actuateurs']
perturbations = params['perturbations']


#temp.
temperature_points = {name: [] for name in params['points_suivi']}

#construction grilles
x = np.linspace(0, Lx * 1e3, Nx)
y = np.linspace(0, Ly * 1e3, Ny)
X, Y = np.meshgrid(x, y)

#interface pour contrôle
root = tk.Tk()
root.title("Interface de contrôle de la simulation")

#curseur d'ajustement de puissance
puissance_var = tk.DoubleVar(value=actuateurs[0]['puissance'])
puissance_label = ttk.Label(root, text="Puissance de l'actuateur (W)")
puissance_label.pack()
puissance_slider = ttk.Scale(root, from_=1, to=1000, variable=puissance_var, orient='horizontal')
puissance_slider.pack()





#bouton démarrage
start_button = ttk.Button(root, text="Démarrer la simulation")
start_button.pack()

#start de la simulation
fig = plt.figure(figsize=(14, 6))
ax1 = fig.add_subplot(131)
ax2 = fig.add_subplot(132, projection='3d')
ax3 = fig.add_subplot(133)
cmap = plt.get_cmap('PuRd')

#graphiques
im = ax1.imshow(T, cmap=cmap, interpolation='nearest')
ax1.set_xlabel("X (mm)")
ax1.set_ylabel("Y (mm)")

surf = ax2.plot_surface(X, Y, T.T, cmap=cmap)
ax2.set_xlabel("X (mm)")
ax2.set_ylabel("Y (mm)")
ax2.set_zlabel("Température (K)")

time_vector = []

#très important : ne pas changer ;) ahahhaha
temperature_lines = {}
rose_colors = ['deeppink', 'hotpink', 'mediumvioletred', 'orchid', 'palevioletred'] #DO NOT CHANGE, WILL FAIL TO COMPUTE

for (name, _), color in zip(params['points_suivi'].items(), rose_colors):
    line, = ax3.plot([], [], label=name, color=color)
    temperature_lines[name] = line

ax3.set_xlabel("Temps (s)")
ax3.set_ylabel("Température (°C)")
ax3.legend()



#fc de température
def update_temp():
    global T, Temp_nouvelle
    T_new = T.copy()
    #T_new += coeff * (T_air - T_new)
    # Conduction éléments centraux
    T_new[1:-1,1:-1] = T[1:-1, 1:-1] + alpha*dt*((T[2:,1:-1]-2*T[1:-1, 1:-1] +T[0:-2, 1:-1])/(dx**2) +
                                           (T[1:-1,2:]-2*T[1:-1, 1:-1] +T[1:-1, 0:-2])/(dy**2))


    #conduction bords et coins
    T_new[0, 1:-1] += alpha * dt * ((T[1, 1:-1] - T[0, 1:-1]) / dx**2 +
                               (T[0, 2:] - 2 * T[0, 1:-1] + T[0, :-2]) / dy**2)
    
    T_new[-1, 1:-1] += alpha * dt * ((T[-2, 1:-1] - T[-1, 1:-1]) / dx**2 +
                                (T[-1, 2:] - 2 * T[-1, 1:-1] + T[-1, :-2]) / dy**2)
    
    T_new[1:-1, 0] += alpha * dt * ((T[2:, 0] - 2 * T[1:-1, 0] + T[:-2, 0]) / dx**2 +
                               (T[1:-1, 1] - T[1:-1, 0]) / dy**2)
    
    T_new[1:-1, -1] += alpha * dt * ((T[2:, -1] - 2 * T[1:-1, -1] + T[:-2, -1]) / dx**2 +
                                (T[1:-1, -2] - T[1:-1, -1]) / dy**2)
    

    # Coins
    T_new[0, 0] += alpha * dt * ((T[1, 0] - T[0, 0]) / dx**2 + (T[0, 1] - T[0, 0]) / dy**2)
    T_new[0, -1] += alpha * dt * ((T[1, -1] - T[0, -1]) / dx**2 + (T[0, -2] - T[0, -1]) / dy**2)
    T_new[-1, 0] += alpha * dt * ((T[-2, 0] - T[-1, 0]) / dx**2 + (T[-1, 1] - T[-1, 0]) / dy**2)
    T_new[-1, -1] += alpha * dt * ((T[-2, -1] - T[-1, -1]) / dx**2 + (T[-1, -2] - T[-1, -1]) / dy**2)


    # Convection
    Coeff = (h_conv*dt)/(rho*cp)
    T_new[0, :] += Coeff*(T_air-T_new[0,:])*((epaisseur*dx)/(volume))     # haut
    T_new[-1, :] += Coeff*(T_air-T_new[-1,:])*((epaisseur*dx)/(volume))   # bas
    T_new[:,0] += Coeff*(T_air-T_new[:,0])*((epaisseur*dy)/(volume))      # gauche
    T_new[:,-1] += Coeff*(T_air-T_new[:,-1])*((epaisseur*dy)/(volume))    # droite
    T_new[:,:] += 2*Coeff*(T_air-T_new[:,:])*((dx*dy)/volume)      # dessus/dessous

    # Actuateurs
    for act in actuateurs:
        i, j = act['position']
        P_par_element = max(puissance_var.get(), 1)  # Éviter des valeurs trop proches de zéro
        T_new[i, j] += (P_par_element * dt) / (rho * cp * volume)

    T[:, :] = T_new[:, :]


#fc de mise à jour animation
def update(frame):
    global surf
    update_temp()
    im.set_data(T)
    im.autoscale()

    surf.remove()
    surf = ax2.plot_surface(X, Y, T.T, cmap=cmap)

    time_vector.append(frame * dt)
    if len(time_vector) > 300:
        time_vector.pop(0)
        for name in temperature_points:
            temperature_points[name].pop(0)

    for name, pos in params['points_suivi'].items():
        temperature_points[name].append(T[pos[0], pos[1]])
        temperature_lines[name].set_data(time_vector, np.array(temperature_points[name]) - 273)

    ax3.relim()
    ax3.autoscale_view()
    return [im, surf, ax3]

ani = FuncAnimation(fig, update, frames=Nt // 500, interval=50, blit=False)


def start_simulation():
    plt.show()

start_button.config(command=start_simulation)

root.mainloop()


